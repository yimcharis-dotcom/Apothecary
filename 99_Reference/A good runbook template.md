---
tags:
document date:
status:
---

Now you fill each section with **only the minimum that makes it runnable**.

A good runbook note usually has:

- Purpose (1–2 lines)
- Inputs/outputs (so you know what files should exist)
- Step-by-step commands (copy/paste runnable)
- Troubleshooting (what to do when it fails)
- Change log
  
# Template 
  
## Step 1 — Create the note + skeleton

1. In Obsidian, create a new note named: `HKICPA Runbook` (or `HKICPA-Runbook.md` if you prefer file-like names).
    
2. Paste this **empty skeleton** (don’t paste the whole runbook yet):

```
tags:
  - runbook
  - hkicpa
  - automation
  - python
status: draft
---

# HKICPA Volume II – Download Runbook (CSV-driven)

## What this does

## What you need (one-time setup)

## Every update cycle (step-by-step)

## Common failures (troubleshooting)

## Scripts (where to find them)

## Change log
--- 
This keeps you from getting overwhelmed, and it forces the note to stay “operational.”
```

## Step 2 — What is “frontmatter”?

**Frontmatter** is that block at the very top between `---` lines. It’s just structured metadata (key–value pairs) stored inside the note.[](https://notes.nicolevanderhoeven.com/obsidian-playbook/Using+Obsidian/03+Linking+and+organizing/YAML+Frontmatter)​  
Obsidian uses it for things like tags, aliases, status, dates, and for searching/filtering later (especially if you use plugins like Dataview).​
In your case, it’s optional—but useful because:
- You can quickly find all runbooks by tag (e.g., `tag:#runbook`).[](https://notes.nicolevanderhoeven.com/obsidian-playbook/Using+Obsidian/03+Linking+and+organizing/YAML+Frontmatter)​
- You can mark notes as `draft` vs `complete` without changing titles.[](https://help.obsidian.md/properties)​
If you don’t want it right now, you can delete the whole `--- ... ---` block and nothing breaks.

## Step 3 — Fill the runbook sections (what to write)

Now you fill each section with **only the minimum that makes it runnable**.

## “What this does” (2–4 bullets)

Include:

- What it downloads.
- The output folder.
- The core idea: CSV manifest is source of truth.​

Example content (write in your own words):

- Downloads all HKICPA Volume II PDFs.
- Uses `hkicpa_manifest.csv` as the master list (filenames live here).
- Output: `downloads/` (or `downloads_clean/` if renaming from raw).​

## “What you need (one-time setup)”

Include:

- The folder you run from (e.g., `C:\HKICPA`).
- Python deps (`pip install pandas requests pypdf`) based on your scripts/runbook.​
- The list of scripts that must exist (the 5 core ones).​

## “Every update cycle (step-by-step)”

This is the heart. Write it as **numbered steps** with exact filenames and exact commands.

Use your CSV-driven workflow order (keep it consistent):

1. Prepare `contentpage.pdf` and `contents_raw.txt`​
2. `python_extract_links.py` → `hkicpa_links.txt`​
3. `python_generate_manifest.py` → `hkicpa_manifest_draft.csv`​
4. Review/rename to `hkicpa_manifest.csv` (optional)​
5. `python_attach_urls.py` → adds `url` column into `hkicpa_manifest.csv` with the row-count safeguard​
6. Download path: direct download or raw+rename​

Important: put **only one “recommended” path** first (most people choose Path A clean download), then list the alternative.

## “Common failures (troubleshooting)”

Start with only 3 issues (you can expand later):

- URL count ≠ manifest rows → “Counts must match; recheck `contents_raw.txt` and redo manifest generation.”​
- Download fails/timeouts → “Re-run download script; it skips nothing (yet).”
- Filenames look wrong → “Fix in `hkicpa_manifest.csv` and rerun download/rename.”​
## “Scripts (where to find them)”

Decide how you want to store scripts in Obsidian:

- Either keep scripts **inside this note** under headings (easy copy/paste).
- Or keep them as `.py` files in a folder and link them from the note.
### Where to put `contents_raw.txt` and other working files

Your HKICPA project has **two types of files**:

## Type A: Documentation (goes in Obsidian)

- `HKICPA-Runbook.md` — the instructions
- `python_extract_links.py` — the scripts (optional, can link to external files)
**Location:** `40_Experiments/HKICPA-Download/` inside your Obsidian vault

## Type B: Working data (stays OUTSIDE Obsidian)

- `contentpage.pdf` — downloaded from HKICPA website
- `contents_raw.txt` — copy/pasted text from PDF
- `hkicpa_links.txt` — generated by script
- `hkicpa_manifest.csv` — generated by script
- `downloads/` folder — output PDFs

**Location:** `C:\HKICPA\` (or wherever you run the scripts from)

**Why separate?**
- Working files change every quarter when HKICPA updates
- Obsidian is for **knowledge** (what to do), not **data** (temporary inputs/outputs)
- Keeps your vault clean and fast
## “Change log”

This is where you record the “changes we discussed” without rewriting history:

- v1: names.txt approach (old)
- v2: CSV manifest workflow + safeguards (current)​
- vNext: retry/progress/logging (planned)
## Step 4 — Incorporate the improvements we discussed (without rewriting everything)

Instead of editing the whole workflow right now, add a **small “Planned Improvements” block** under Troubleshooting or Change log:

- Add retry logic + exponential backoff to download scripts (planned).
- Add progress indicator (planned).
- Add resume capability (maybe).
This keeps the runbook stable while acknowledging the roadmap.
## 
## Practical Advice

**For this specific project:**
- The runbook is **done**. Don't over-polish it.​
- If you never run it again, chalk it up as learning debt (you now know PDF link extraction, which transfers to other projects).
- If HKICPA updates standards quarterly, you'll break even by Q2 2026.
**For future "simple" automation:**
- **Time-box it**: If manual task = 2 hours, automation should take ≤ 4 hours (1 day). If you're on day 3, stop and evaluate.
- **Document incrementally**: Write the [[Untitled 1/README]] _first_ (what should this do?), then code to match it.
- **Reuse ruthlessly**: Keep a personal repo of scripts. Next "download PDFs from manifest" project starts at 80% done.
**The real insight:** You're not slow—automation is genuinely hard, and documentation overhead is real. The question isn't "who has time for this?" but **"which problems are worth solving this way?"**.​

