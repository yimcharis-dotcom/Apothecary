/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SideNote
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/commentManager.ts
var import_crypto = require("crypto");
var CommentManager = class {
  // Minimum characters to create regex pattern
  constructor(comments) {
    this.MIN_TEXT_LENGTH = 3;
    this.comments = comments;
  }
  /**
   * Generate SHA256 hash of the selected text
   * @param text The text to hash
   * @returns The hash string
   */
  generateHash(text) {
    return (0, import_crypto.createHash)("sha256").update(text).digest("hex");
  }
  getCommentsForFile(filePath) {
    return this.comments.filter((comment) => comment.filePath === filePath);
  }
  addComment(newComment) {
    if (!newComment.selectedTextHash) {
      newComment.selectedTextHash = this.generateHash(newComment.selectedText);
    }
    this.comments.push(newComment);
  }
  editComment(timestamp, newCommentText) {
    const commentToEdit = this.comments.find((comment) => comment.timestamp === timestamp);
    if (commentToEdit) {
      commentToEdit.comment = newCommentText;
    }
  }
  deleteComment(timestamp) {
    const indexToDelete = this.comments.findIndex((comment) => comment.timestamp === timestamp);
    if (indexToDelete > -1) {
      this.comments.splice(indexToDelete, 1);
    }
  }
  /**
   * Delete all orphaned comments
   * @returns The number of orphaned comments deleted
   */
  deleteOrphanedComments() {
    const initialLength = this.comments.length;
    for (let i = this.comments.length - 1; i >= 0; i--) {
      if (this.comments[i].isOrphaned) {
        this.comments.splice(i, 1);
      }
    }
    return initialLength - this.comments.length;
  }
  /**
   * Get all orphaned comments
   * @returns Array of orphaned comments
   */
  getOrphanedComments() {
    return this.comments.filter((comment) => comment.isOrphaned);
  }
  /**
   * Get the count of orphaned comments
   * @returns Number of orphaned comments
   */
  getOrphanedCommentCount() {
    return this.comments.filter((comment) => comment.isOrphaned).length;
  }
  renameFile(oldPath, newPath) {
    this.comments.forEach((comment) => {
      if (comment.filePath === oldPath) {
        comment.filePath = newPath;
      }
    });
  }
  updateComments(newComments) {
    this.comments = newComments;
  }
  getComments() {
    return this.comments;
  }
  /**
   * Calculate distance between two positions (for finding closest match)
   * @param line1 First line number
   * @param char1 First character position
   * @param line2 Second line number
   * @param char2 Second character position
   * @returns Distance score (lower is closer)
   */
  calculateDistance(line1, char1, line2, char2) {
    const lineDistance = Math.abs(line1 - line2);
    const charDistance = Math.abs(char1 - char2);
    return lineDistance * 1e3 + charDistance;
  }
  /**
   * Find text position with hash verification for accuracy
   * Strategy 1: Search around hint coordinates and verify hash match
   * When multiple matches exist, returns the one closest to the hint coordinates
   * @param fileContent The current file content
   * @param selectedText The text to find
   * @param selectedTextHash The hash of the selected text
   * @param hintStartLine Starting line as a hint
   * @param hintStartChar Starting character as a hint
   * @param hintEndLine Ending line as a hint
   * @returns Object with line, startChar, endChar or null if not found
   */
  findTextPositionWithHashVerification(fileContent, selectedText, selectedTextHash, hintStartLine, hintStartChar, hintEndLine) {
    if (!selectedText || selectedText.length < this.MIN_TEXT_LENGTH) {
      return null;
    }
    const lines = fileContent.split("\n");
    const escapedText = selectedText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(escapedText, "g");
    const startLine = Math.max(0, hintStartLine - 10);
    const endLine = Math.min(lines.length, hintEndLine + 10);
    let candidates = [];
    for (let lineNum = startLine; lineNum < endLine; lineNum++) {
      let match;
      regex.lastIndex = 0;
      while ((match = regex.exec(lines[lineNum])) !== null) {
        const foundText = lines[lineNum].substring(match.index, match.index + selectedText.length);
        if (this.generateHash(foundText) === selectedTextHash) {
          const distance = this.calculateDistance(lineNum, match.index, hintStartLine, hintStartChar);
          candidates.push({
            line: lineNum,
            startChar: match.index,
            endChar: match.index + selectedText.length,
            distance
          });
        }
      }
    }
    if (candidates.length > 0) {
      candidates.sort((a, b) => a.distance - b.distance);
      const closest = candidates[0];
      return {
        line: closest.line,
        startChar: closest.startChar,
        endChar: closest.endChar
      };
    }
    return null;
  }
  /**
   * Find text by hash across the entire file
   * Strategy 2: Search entire file for matching hash using optimized approach
   * When multiple matches exist, returns the one closest to the hint coordinates
   * @param fileContent The current file content
   * @param selectedTextHash The hash to match
   * @param originalTextLength The length of the original selected text (optimization hint)
   * @param hintStartLine Starting line hint for proximity scoring
   * @param hintStartChar Starting character hint for proximity scoring
   * @returns Object with line, startChar, endChar, text or null if not found
   */
  findTextByHashOptimized(fileContent, selectedTextHash, originalTextLength, hintStartLine, hintStartChar) {
    const lines = fileContent.split("\n");
    let candidates = [];
    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];
      if (line.length >= originalTextLength) {
        for (let startChar = 0; startChar <= line.length - originalTextLength; startChar++) {
          const candidate = line.substring(startChar, startChar + originalTextLength);
          if (this.generateHash(candidate) === selectedTextHash) {
            const distance = hintStartLine !== void 0 && hintStartChar !== void 0 ? this.calculateDistance(lineNum, startChar, hintStartLine, hintStartChar) : 0;
            candidates.push({
              line: lineNum,
              startChar,
              endChar: startChar + originalTextLength,
              text: candidate,
              distance
            });
          }
        }
      }
      const minLength = Math.max(this.MIN_TEXT_LENGTH, Math.floor(originalTextLength * 0.8));
      const maxLength = Math.min(line.length, Math.ceil(originalTextLength * 1.2));
      for (let length = minLength; length <= maxLength; length++) {
        if (length === originalTextLength) continue;
        for (let startChar = 0; startChar <= line.length - length; startChar++) {
          const candidate = line.substring(startChar, startChar + length);
          if (this.generateHash(candidate) === selectedTextHash) {
            const distance = hintStartLine !== void 0 && hintStartChar !== void 0 ? this.calculateDistance(lineNum, startChar, hintStartLine, hintStartChar) : 0;
            candidates.push({
              line: lineNum,
              startChar,
              endChar: startChar + length,
              text: candidate,
              distance
            });
          }
        }
      }
    }
    if (candidates.length > 0) {
      candidates.sort((a, b) => a.distance - b.distance);
      const closest = candidates[0];
      return {
        line: closest.line,
        startChar: closest.startChar,
        endChar: closest.endChar,
        text: closest.text
      };
    }
    return null;
  }
  /**
   * Find the position of selected text in the current file content
   * Uses regex matching as a fallback to line-based positioning
   * When multiple matches exist, returns the one closest to hint coordinates
   * @param fileContent The current file content
   * @param selectedText The text to find
   * @param hintStartLine Optional starting line as a hint (performance optimization)
   * @param hintEndLine Optional ending line as a hint (performance optimization)
   * @param hintStartChar Optional starting character as a hint (performance optimization)
   * @returns Object with line, startChar, endChar or null if not found
   */
  findTextPosition(fileContent, selectedText, hintStartLine, hintEndLine, hintStartChar) {
    if (!selectedText || selectedText.length < this.MIN_TEXT_LENGTH) {
      return null;
    }
    const lines = fileContent.split("\n");
    const escapedText = selectedText.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(escapedText, "g");
    let candidates = [];
    let startLine = 0;
    let endLine = lines.length;
    if (hintStartLine !== void 0 && hintEndLine !== void 0) {
      startLine = Math.max(0, hintStartLine - 10);
      endLine = Math.min(lines.length, hintEndLine + 10);
    }
    for (let lineNum = startLine; lineNum < endLine; lineNum++) {
      let match;
      regex.lastIndex = 0;
      while ((match = regex.exec(lines[lineNum])) !== null) {
        const distance = hintStartLine !== void 0 && hintStartChar !== void 0 ? this.calculateDistance(lineNum, match.index, hintStartLine, hintStartChar) : 0;
        candidates.push({
          line: lineNum,
          startChar: match.index,
          endChar: match.index + selectedText.length,
          distance
        });
      }
    }
    if (candidates.length > 0) {
      candidates.sort((a, b) => a.distance - b.distance);
      const closest = candidates[0];
      return {
        line: closest.line,
        startChar: closest.startChar,
        endChar: closest.endChar
      };
    }
    if (hintStartLine !== void 0 && hintEndLine !== void 0) {
      candidates = [];
      for (let lineNum = 0; lineNum < lines.length; lineNum++) {
        let match;
        regex.lastIndex = 0;
        while ((match = regex.exec(lines[lineNum])) !== null) {
          const distance = hintStartLine !== void 0 && hintStartChar !== void 0 ? this.calculateDistance(lineNum, match.index, hintStartLine, hintStartChar) : 0;
          candidates.push({
            line: lineNum,
            startChar: match.index,
            endChar: match.index + selectedText.length,
            distance
          });
        }
      }
      if (candidates.length > 0) {
        candidates.sort((a, b) => a.distance - b.distance);
        const closest = candidates[0];
        return {
          line: closest.line,
          startChar: closest.startChar,
          endChar: closest.endChar
        };
      }
    }
    return null;
  }
  /**
   * Update comment coordinates based on file content changes
   * Uses 3-stage hash-based matching strategy:
   * 1. Search near old coordinates with hash verification
   * 2. Search entire file by hash
   * 3. Mark as orphaned if not found
   * @param fileContent The current file content
   * @param filePath The path of the file that was changed
   */
  updateCommentCoordinatesForFile(fileContent, filePath) {
    const fileComments = this.comments.filter((comment) => comment.filePath === filePath);
    fileComments.forEach((comment) => {
      if (comment.isOrphaned) {
        return;
      }
      let newPosition = null;
      if (comment.selectedTextHash) {
        newPosition = this.findTextPositionWithHashVerification(
          fileContent,
          comment.selectedText,
          comment.selectedTextHash,
          comment.startLine,
          comment.startChar,
          comment.endLine
        );
      }
      if (!newPosition && comment.selectedTextHash && comment.selectedText) {
        const hashMatch = this.findTextByHashOptimized(
          fileContent,
          comment.selectedTextHash,
          comment.selectedText.length,
          comment.startLine,
          comment.startChar
        );
        if (hashMatch) {
          newPosition = hashMatch;
          comment.selectedText = hashMatch.text;
        }
      }
      if (!newPosition && !comment.selectedTextHash) {
        newPosition = this.findTextPosition(
          fileContent,
          comment.selectedText,
          comment.startLine,
          comment.endLine,
          comment.startChar
        );
      }
      if (newPosition) {
        comment.startLine = newPosition.line;
        comment.startChar = newPosition.startChar;
        comment.endLine = newPosition.line;
        comment.endChar = newPosition.endChar;
      } else {
        comment.isOrphaned = true;
      }
    });
  }
};

// src/main.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
async function generateHash(text) {
  try {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  } catch (error) {
    try {
      const nodeCrypto = require("crypto");
      return nodeCrypto.createHash("sha256").update(text).digest("hex");
    } catch (e) {
      new import_obsidian.Notice("Warning: Could not generate proper hash, using fallback");
      let hash = 0;
      for (let i = 0; i < text.length; i++) {
        const char = text.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(16);
    }
  }
}
var forceUpdateEffect = import_state.StateEffect.define();
var DEFAULT_SETTINGS = {
  commentSortOrder: "position",
  showHighlights: true,
  markdownFolder: "side-note-comments",
  highlightColor: "#FFC800",
  highlightOpacity: 0.2
};
var SideNoteView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin, file = null) {
    super(leaf);
    this.file = null;
    this.activeCommentTimestamp = null;
    this.plugin = plugin;
    this.file = file;
  }
  getViewType() {
    return "sidenote-view";
  }
  getDisplayText() {
    return "Side Note";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    await Promise.resolve();
    if (!this.file) {
      this.file = this.app.workspace.getActiveFile();
    }
    this.renderComments();
  }
  async setState(state, result) {
    if (state.filePath) {
      const file = this.app.vault.getAbstractFileByPath(state.filePath);
      if (file instanceof import_obsidian.TFile) {
        this.file = file;
        this.renderComments();
      }
    }
    await super.setState(state, result);
  }
  /**
   * Update view to show comments for a specific file
   * Called when active file changes
   */
  updateActiveFile(file) {
    this.file = file;
    this.renderComments();
  }
  /**
   * Highlight and scroll to a specific comment
   */
  highlightComment(timestamp) {
    this.activeCommentTimestamp = timestamp;
    this.renderComments();
    setTimeout(() => {
      const commentEl = this.containerEl.querySelector(`[data-comment-timestamp="${timestamp}"]`);
      if (commentEl) {
        commentEl.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }, 100);
  }
  renderComments() {
    this.containerEl.empty();
    this.containerEl.addClass("sidenote-view-container");
    if (this.file) {
      let commentsForFile = this.plugin.commentManager.getCommentsForFile(this.file.path);
      if (this.plugin.settings.commentSortOrder === "position") {
        commentsForFile.sort((a, b) => {
          if (a.startLine === b.startLine) {
            return a.startChar - b.startChar;
          }
          return a.startLine - b.startLine;
        });
      } else {
        commentsForFile.sort((a, b) => a.timestamp - b.timestamp);
      }
      if (commentsForFile.length > 0) {
        const commentsContainer = this.containerEl.createDiv("sidenote-comments-container");
        commentsForFile.forEach((comment) => {
          const commentEl = commentsContainer.createDiv("sidenote-comment-item");
          commentEl.setAttribute("data-comment-timestamp", comment.timestamp.toString());
          if (this.activeCommentTimestamp === comment.timestamp) {
            commentEl.addClass("active");
          }
          const headerEl = commentEl.createDiv("sidenote-comment-header");
          const textInfoEl = headerEl.createDiv("sidenote-comment-text-info");
          textInfoEl.createEl("h4", { text: comment.selectedText, cls: "sidenote-selected-text" });
          textInfoEl.createEl("small", { text: new Date(comment.timestamp).toLocaleString(), cls: "sidenote-timestamp" });
          const actionsEl = headerEl.createDiv("sidenote-comment-actions");
          commentEl.onclick = async () => {
            let targetLeaf = null;
            this.app.workspace.iterateAllLeaves((leaf) => {
              var _a;
              if (leaf.view instanceof import_obsidian.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === comment.filePath) {
                targetLeaf = leaf;
                return false;
              }
            });
            if (!targetLeaf) {
              const file = this.app.vault.getAbstractFileByPath(comment.filePath);
              if (file instanceof import_obsidian.TFile) {
                const newLeaf = this.app.workspace.getLeaf(true);
                await newLeaf.openFile(file);
                targetLeaf = newLeaf;
              }
            }
            if (targetLeaf && targetLeaf.view instanceof import_obsidian.MarkdownView) {
              this.app.workspace.setActiveLeaf(targetLeaf, { focus: true });
              const editor = targetLeaf.view.editor;
              const fileContent = editor.getValue();
              let startLine = comment.startLine;
              let startChar = comment.startChar;
              let endLine = comment.endLine;
              let endChar = comment.endChar;
              const lines = fileContent.split("\n");
              let textMatches = false;
              if (startLine < lines.length) {
                const line = lines[startLine];
                const extractedText = line.substring(startChar, endChar);
                if (comment.selectedTextHash) {
                  const crypto2 = require("crypto");
                  const extractedHash = crypto2.createHash("sha256").update(extractedText).digest("hex");
                  textMatches = extractedHash === comment.selectedTextHash;
                } else {
                  textMatches = extractedText === comment.selectedText;
                }
              }
              if (!textMatches) {
                this.plugin.commentManager.updateCommentCoordinatesForFile(fileContent, comment.filePath);
                await this.plugin.saveData();
                startLine = comment.startLine;
                startChar = comment.startChar;
                endLine = comment.endLine;
                endChar = comment.endChar;
              }
              editor.setSelection(
                { line: startLine, ch: startChar },
                { line: endLine, ch: endChar }
              );
              editor.scrollIntoView({
                from: { line: startLine, ch: 0 },
                to: { line: endLine, ch: 0 }
              }, true);
              editor.focus();
            } else {
              new import_obsidian.Notice("Failed to jump to Markdown view.");
            }
          };
          const contentWrapper = commentEl.createDiv({ cls: "sidenote-comment-content" });
          import_obsidian.MarkdownRenderer.renderMarkdown(
            comment.comment || "",
            contentWrapper,
            comment.filePath,
            this.plugin
          );
          const menuButton = actionsEl.createEl("button", { text: "...", cls: "sidenote-menu-button" });
          const menuContainer = actionsEl.createDiv("sidenote-action-menu");
          const editOption = menuContainer.createEl("button", { text: "Edit", cls: "sidenote-menu-option sidenote-menu-edit" });
          editOption.onclick = (e) => {
            e.stopPropagation();
            menuContainer.classList.remove("visible");
            new CommentModal(this.app, (editedComment) => {
              this.plugin.editComment(comment.timestamp, editedComment);
            }, comment.comment).open();
          };
          const deleteOption = menuContainer.createEl("button", { text: "Delete", cls: "sidenote-menu-option sidenote-menu-delete" });
          deleteOption.onclick = (e) => {
            e.stopPropagation();
            menuContainer.classList.remove("visible");
            this.plugin.deleteComment(comment.timestamp);
          };
          menuButton.onclick = (e) => {
            e.stopPropagation();
            menuContainer.classList.toggle("visible");
          };
          document.addEventListener("click", () => {
            menuContainer.classList.remove("visible");
          });
        });
      } else {
        const emptyStateEl = this.containerEl.createDiv("sidenote-empty-state");
        emptyStateEl.createEl("p", { text: "No comments for this file yet." });
        emptyStateEl.createEl("p", { text: "Select text in your note and use the 'add comment to selection' command to get started." });
      }
    } else {
      const emptyStateEl = this.containerEl.createDiv("sidenote-empty-state");
      emptyStateEl.createEl("p", { text: "No file selected." });
      emptyStateEl.createEl("p", { text: "Open a file to see its comments." });
    }
  }
  getState() {
    return {
      filePath: this.file ? this.file.path : null
    };
  }
  onunload() {
  }
};
async function switchToSideNoteView(app) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian.Notice("No active Markdown file found.");
    return;
  }
  let leaf = null;
  try {
    leaf = app.workspace.getLeaf("split", "vertical");
  } catch (error) {
    new import_obsidian.Notice("Failed to create a new split view for comments.");
    console.error("Error creating split leaf:", error);
    return;
  }
  if (leaf) {
    await leaf.setViewState({
      type: "sidenote-view",
      state: { filePath: activeFile.path },
      // CustomViewState expects filePath
      active: true
      // Make the new view active
    });
    void app.workspace.revealLeaf(leaf);
  } else {
    new import_obsidian.Notice("Failed to create or find a leaf for the comment view.");
  }
}
var CommentModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit, initialComment = "") {
    super(app);
    this.textareaEl = null;
    this.onSubmit = onSubmit;
    this.initialComment = initialComment;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("sidenote-comment-modal");
    contentEl.createEl("h2", { text: this.initialComment ? "Edit comment" : "Add comment" });
    const inputContainer = contentEl.createDiv("sidenote-comment-input-container");
    const input = inputContainer.createEl("textarea");
    input.placeholder = "Enter your comment...";
    input.value = this.initialComment;
    input.classList.add("sidenote-textarea");
    this.textareaEl = input;
    input.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        this.submitComment();
      }
      if (e.key === "Escape") {
        e.preventDefault();
        this.close();
      }
    });
    const footer = contentEl.createDiv("sidenote-modal-footer");
    const cancelButton = footer.createEl("button", {
      text: "Cancel",
      cls: "sidenote-modal-cancel-btn"
    });
    const handleCancel = () => {
      this.close();
    };
    cancelButton.onclick = handleCancel;
    cancelButton.addEventListener("click", handleCancel, false);
    cancelButton.addEventListener("touchstart", (e) => {
      e.preventDefault();
    }, false);
    cancelButton.addEventListener("touchend", (e) => {
      e.preventDefault();
      e.stopPropagation();
      handleCancel();
    }, false);
    const button = footer.createEl("button", {
      text: this.initialComment ? "Save" : "Add",
      cls: "mod-cta sidenote-modal-submit-btn"
    });
    button.setAttribute("type", "button");
    const handleSubmit = async () => {
      if (this.textareaEl) {
        this.textareaEl.blur();
      }
      await this.submitComment();
    };
    button.onclick = handleSubmit;
    button.addEventListener("click", handleSubmit, false);
    button.addEventListener("touchstart", (e) => {
      e.preventDefault();
    }, false);
    button.addEventListener("touchend", (e) => {
      e.preventDefault();
      e.stopPropagation();
      handleSubmit();
    }, false);
    setTimeout(() => {
      input.focus();
      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        input.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }, 100);
    this.modalEl.addEventListener("click", (e) => {
      if (e.target === this.modalEl) {
        this.close();
      }
    });
    document.body.style.overflow = "hidden";
  }
  async submitComment() {
    if (this.textareaEl) {
      this.comment = this.textareaEl.value;
      try {
        this.onSubmit(this.comment);
      } catch (error) {
        new import_obsidian.Notice("Error: Failed to save comment");
        console.error("Error in onSubmit:", error);
        return;
      }
      this.close();
    } else {
      new import_obsidian.Notice("Error: Comment field is empty");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    document.body.style.overflow = "";
  }
};
var SideNoteSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Comment sort order").setDesc("Choose how comments are sorted in the custom view.").addDropdown(
      (dropdown) => dropdown.addOption("timestamp", "By timestamp").addOption("position", "By position in file").setValue(this.plugin.settings.commentSortOrder).onChange(async (value) => {
        this.plugin.settings.commentSortOrder = value;
        await this.plugin.saveData();
        this.app.workspace.getLeavesOfType("sidenote-view").forEach((leaf) => {
          if (leaf.view instanceof SideNoteView) {
            leaf.view.renderComments();
          }
        });
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show highlights in editor").setDesc("Display highlights for commented text in the editor. After changing this setting, please restart Obsidian to see the effect.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showHighlights).onChange(async (value) => {
        this.plugin.settings.showHighlights = value;
        await this.plugin.saveData();
        this.plugin.refreshEditorDecorations();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Highlight color").setDesc("Choose the color for highlighted comments in the editor").addColorPicker(
      (colorPicker) => colorPicker.setValue(this.plugin.settings.highlightColor || "#FFC800").onChange(async (value) => {
        this.plugin.settings.highlightColor = value;
        await this.plugin.saveData();
        this.plugin.applyHighlightColor();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Highlight opacity").setDesc("Set the transparency of the highlight (0 = transparent, 1 = opaque)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.highlightOpacity || 0.2).onChange(async (value) => {
        this.plugin.settings.highlightOpacity = value;
        await this.plugin.saveData();
        this.plugin.applyHighlightColor();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Markdown comments folder").setDesc("Folder (relative to vault) where sidenote markdown backup files are stored").addText(
      (text) => text.setPlaceholder("side-note-comments").setValue(this.plugin.settings.markdownFolder || "").onChange(async (value) => {
        this.plugin.settings.markdownFolder = value.trim() || "side-note-comments";
        await this.plugin.saveData();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Create Markdown Backup").setDesc("Export all comments to markdown files in the configured folder").addButton(
      (button) => button.setButtonText("Create Backup").onClick(async () => {
        await this.plugin.migrateInlineCommentsToMarkdown();
        new import_obsidian.Notice("Markdown backup created successfully!");
      })
    );
    const orphanedCount = this.plugin.commentManager.getOrphanedCommentCount();
    new import_obsidian.Setting(containerEl).setName("Orphaned comments").setDesc(`There are ${orphanedCount} orphaned comment(s). These are comments whose original text was deleted.`);
    new import_obsidian.Setting(containerEl).addButton(
      (button) => button.setButtonText(`Delete ${orphanedCount} orphaned comment(s)`).setWarning().onClick(async () => {
        const deleted = this.plugin.commentManager.deleteOrphanedComments();
        await this.plugin.saveData();
        this.app.workspace.getLeavesOfType("sidenote-view").forEach((leaf) => {
          if (leaf.view instanceof SideNoteView) {
            leaf.view.renderComments();
          }
        });
        new import_obsidian.Notice(`Deleted ${deleted} orphaned comment(s)!`);
        this.display();
      }).setDisabled(orphanedCount === 0)
    );
  }
};
var SideNote = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.comments = [];
  }
  /** Ensure markdown comment folder exists and return normalized path */
  async ensureCommentFolder() {
    const folder = this.settings.markdownFolder.trim() || DEFAULT_SETTINGS.markdownFolder;
    const normalized = folder.replace(/^\/+|\/+$/g, "");
    const exists = await this.app.vault.adapter.exists(normalized);
    if (!exists) {
      await this.app.vault.createFolder(normalized);
    }
    return normalized;
  }
  /** Build side-note file path for a given note */
  getSideNoteFilePath(notePath) {
    const folder = this.settings.markdownFolder.trim() || DEFAULT_SETTINGS.markdownFolder;
    const normalized = folder.replace(/^\/+|\/+$/g, "");
    const base = notePath.replace(/\.md$/i, "").replace(/\//g, "__");
    return `${normalized}/${base}-sidenote.md`;
  }
  /** Build markdown block with marker */
  buildMarkdownBlock(excerpt, body, timestamp) {
    const safeExcerpt = excerpt || "(no excerpt)";
    return `## ${safeExcerpt}
<!-- side-note:${timestamp} -->
${body}

---`;
  }
  /** Write or append comment to markdown file and return path */
  async writeCommentToMarkdown(notePath, excerpt, body, timestamp) {
    const folder = await this.ensureCommentFolder();
    const filePath = this.getSideNoteFilePath(notePath);
    const block = this.buildMarkdownBlock(excerpt, body, timestamp);
    const existing = this.app.vault.getAbstractFileByPath(filePath);
    if (existing instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(existing);
      const updated = content.trim().length === 0 ? block : `${content}

${block}`;
      await this.app.vault.modify(existing, updated);
    } else {
      const header = `# Side Notes for ${notePath}

`;
      await this.app.vault.create(filePath, `${header}${block}`);
    }
    return filePath;
  }
  /** Update markdown block by timestamp */
  async updateMarkdownComment(comment, newBody) {
    const filePath = comment.commentPath || this.getSideNoteFilePath(comment.filePath);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile)) return;
    const content = await this.app.vault.read(file);
    const marker = `<!-- side-note:${comment.timestamp} -->`;
    const blockRegex = new RegExp(`(^|
)## .*?
${marker}
[^]*?(?=
---
|$)`, "m");
    if (!blockRegex.test(content)) return;
    const replacement = this.buildMarkdownBlock(comment.selectedText, newBody, comment.timestamp);
    const updated = content.replace(blockRegex, replacement);
    await this.app.vault.modify(file, updated);
  }
  /** Delete markdown block by timestamp */
  async deleteMarkdownComment(comment) {
    const filePath = comment.commentPath || this.getSideNoteFilePath(comment.filePath);
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile)) return;
    const content = await this.app.vault.read(file);
    const marker = `<!-- side-note:${comment.timestamp} -->`;
    const blockRegex = new RegExp(`(^|
)## .*?
${marker}
[^]*?(?:
---
|$)`, "m");
    if (!blockRegex.test(content)) return;
    const updated = content.replace(blockRegex, "").trim();
    await this.app.vault.modify(file, updated.length ? updated + "\n" : "");
  }
  async onload() {
    await this.loadPluginData();
    this.commentManager = new CommentManager(this.comments);
    await this.migrateComments();
    this.registerEditorExtension([this.createHighlightPlugin()]);
    this.addSettingTab(new SideNoteSettingTab(this.app, this));
    this.registerView("sidenote-view", (leaf) => new SideNoteView(leaf, this));
    this.addCommand({
      id: "open-comment-view",
      name: "Open in Split View",
      callback: () => {
        void switchToSideNoteView(this.app);
      }
    });
    this.addCommand({
      id: "activate-view",
      name: "Open in Sidebar",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "add-comment-to-selection",
      name: "Add comment to selection",
      icon: "message-square",
      editorCallback: async (editor, view) => {
        var _a;
        const selection = editor.getSelection();
        const cursorStart = editor.getCursor("from");
        const cursorEnd = editor.getCursor("to");
        const filePath = (_a = view.file) == null ? void 0 : _a.path;
        if (selection && selection.trim().length > 0 && filePath) {
          new CommentModal(this.app, async (comment) => {
            const selectedTextHash = await generateHash(selection);
            const newComment = {
              filePath,
              startLine: cursorStart.line,
              startChar: cursorStart.ch,
              endLine: cursorEnd.line,
              endChar: cursorEnd.ch,
              selectedText: selection,
              selectedTextHash,
              comment,
              timestamp: Date.now(),
              isOrphaned: false
            };
            this.addComment(newComment);
          }).open();
        } else {
          new import_obsidian.Notice("Please select some text to add a comment.");
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (editor.somethingSelected()) {
          menu.addItem((item) => {
            item.setTitle("Add comment to selection").setIcon("message-square").onClick(async () => {
              var _a;
              const selection = editor.getSelection();
              const cursorStart = editor.getCursor("from");
              const cursorEnd = editor.getCursor("to");
              const filePath = (_a = view.file) == null ? void 0 : _a.path;
              if (selection && selection.trim().length > 0 && filePath) {
                new CommentModal(this.app, async (comment) => {
                  const selectedTextHash = await generateHash(selection);
                  const newComment = {
                    filePath,
                    startLine: cursorStart.line,
                    startChar: cursorStart.ch,
                    endLine: cursorEnd.line,
                    endChar: cursorEnd.ch,
                    selectedText: selection,
                    selectedTextHash,
                    comment,
                    timestamp: Date.now(),
                    isOrphaned: false
                  };
                  this.addComment(newComment);
                }).open();
              } else {
                new import_obsidian.Notice("Please select some text to add a comment.");
              }
            });
          });
        }
      })
    );
    this.addRibbonIcon("message-square", "Side Note: Open in Sidebar", () => {
      this.activateView();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf && leaf.view instanceof import_obsidian.MarkdownView) {
          const file = leaf.view.file;
          this.app.workspace.getLeavesOfType("sidenote-view").forEach((sideNoteLeaf) => {
            if (sideNoteLeaf.view instanceof SideNoteView) {
              sideNoteLeaf.view.updateActiveFile(file);
            }
          });
          this.refreshEditorDecorations();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile) {
          this.commentManager.renameFile(oldPath, file.path);
          void this.saveData();
          this.app.workspace.getLeavesOfType("sidenote-view").forEach((leaf) => {
            if (leaf.view instanceof SideNoteView) {
              leaf.view.renderComments();
            }
          });
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        var _a;
        if (file.path === ".obsidian/plugins/side-note/data.json" || file instanceof import_obsidian.TFile && file.name === "data.json" && ((_a = file.parent) == null ? void 0 : _a.name) === "side-note") {
          try {
            await this.loadPluginData();
            this.commentManager.updateComments(this.comments);
            this.app.workspace.getLeavesOfType("sidenote-view").forEach((leaf) => {
              if (leaf.view instanceof SideNoteView) {
                leaf.view.renderComments();
              }
            });
          } catch (error) {
            console.error("Error reloading plugin data:", error);
          }
        } else if (file instanceof import_obsidian.TFile && file.extension === "md") {
          try {
            const fileContent = await this.app.vault.read(file);
            this.commentManager.updateCommentCoordinatesForFile(fileContent, file.path);
            await this.saveData();
            this.app.workspace.getLeavesOfType("sidenote-view").forEach((leaf) => {
              if (leaf.view instanceof SideNoteView) {
                leaf.view.renderComments();
              }
            });
          } catch (error) {
            console.error("Error updating comment coordinates:", error);
          }
        }
      })
    );
  }
  /**
   * Activate the Side Note view and highlight a specific comment
   */
  async activateViewAndHighlightComment(timestamp) {
    await this.activateView();
    const leaves = this.app.workspace.getLeavesOfType("sidenote-view");
    leaves.forEach((leaf) => {
      if (leaf.view instanceof SideNoteView) {
        leaf.view.highlightComment(timestamp);
      }
    });
  }
  /**
   * Activate the Side Note view - open it in the right sidebar if not already open
   */
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType("sidenote-view");
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({ type: "sidenote-view", active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (leaf.view instanceof SideNoteView) {
        const activeFile = workspace.getActiveFile();
        leaf.view.updateActiveFile(activeFile);
      }
    }
  }
  async onCommentsChanged(message) {
    await this.saveData();
    this.app.workspace.getLeavesOfType("sidenote-view").forEach((leaf) => {
      if (leaf.view instanceof SideNoteView) {
        leaf.view.renderComments();
      }
    });
    this.refreshEditorDecorations();
    new import_obsidian.Notice(message);
  }
  async addComment(newComment) {
    this.commentManager.addComment(newComment);
    void this.onCommentsChanged("Comment added!");
  }
  async editComment(timestamp, newCommentText) {
    const existing = this.commentManager.getComments().find((c) => c.timestamp === timestamp);
    if (existing) {
      existing.comment = newCommentText;
    }
    void this.onCommentsChanged("Comment updated!");
  }
  async deleteComment(timestamp) {
    this.commentManager.deleteComment(timestamp);
    void this.onCommentsChanged("Comment deleted!");
  }
  async loadPluginData() {
    const loadedData = Object.assign({}, { comments: [] }, DEFAULT_SETTINGS, await this.loadData());
    this.settings = {
      commentSortOrder: loadedData.commentSortOrder || DEFAULT_SETTINGS.commentSortOrder,
      showHighlights: loadedData.showHighlights !== void 0 ? loadedData.showHighlights : DEFAULT_SETTINGS.showHighlights,
      markdownFolder: loadedData.markdownFolder || DEFAULT_SETTINGS.markdownFolder,
      highlightColor: loadedData.highlightColor || DEFAULT_SETTINGS.highlightColor,
      highlightOpacity: loadedData.highlightOpacity !== void 0 ? loadedData.highlightOpacity : DEFAULT_SETTINGS.highlightOpacity
    };
    this.comments = loadedData.comments || [];
    this.applyHighlightColor();
  }
  /**
   * Migrate existing comments to add missing hashes and initialize flags
   */
  async migrateComments() {
    let needsSave = false;
    for (const comment of this.comments) {
      if (!comment.selectedTextHash && comment.selectedText) {
        comment.selectedTextHash = await generateHash(comment.selectedText);
        needsSave = true;
      }
      if (comment.isOrphaned === void 0) {
        comment.isOrphaned = false;
        needsSave = true;
      }
    }
    if (needsSave) {
      await this.saveData();
      console.log("Migrated comments: added hashes and initialized flags");
    }
  }
  /**
   * Export existing inline comments to markdown files
   */
  async migrateInlineCommentsToMarkdown() {
    let changed = false;
    for (const comment of this.comments) {
      if (!comment.commentPath) {
        const path = await this.writeCommentToMarkdown(comment.filePath, comment.selectedText, comment.comment, comment.timestamp);
        comment.commentPath = path;
        changed = true;
      }
    }
    if (changed) {
      await this.saveData();
    }
  }
  /**
   * Apply highlight color settings by updating CSS variables
   */
  applyHighlightColor() {
    const root = document.documentElement;
    const color = this.settings.highlightColor;
    const opacity = this.settings.highlightOpacity;
    const rgb = this.hexToRgb(color);
    const rgbaColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
    const rgbaHoverColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${Math.min(opacity + 0.15, 1)})`;
    const rgbaBorderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${Math.min(opacity + 0.4, 1)})`;
    const rgbaOrphaned = `rgba(255, 100, 100, ${opacity})`;
    const rgbaOrphanedHover = `rgba(255, 100, 100, ${Math.min(opacity + 0.15, 1)})`;
    const rgbaOrphanedBorder = `rgba(255, 100, 100, ${Math.min(opacity + 0.35, 1)})`;
    root.style.setProperty("--sidenote-highlight-color", rgbaColor);
    root.style.setProperty("--sidenote-highlight-hover", rgbaHoverColor);
    root.style.setProperty("--sidenote-highlight-border", rgbaBorderColor);
    root.style.setProperty("--sidenote-orphaned-color", rgbaOrphaned);
    root.style.setProperty("--sidenote-orphaned-hover", rgbaOrphanedHover);
    root.style.setProperty("--sidenote-orphaned-border", rgbaOrphanedBorder);
    this.refreshEditorDecorations();
  }
  /**
   * Convert hex color to RGB object
   */
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 255, g: 200, b: 0 };
  }
  async saveData() {
    const dataToSave = {
      ...this.settings,
      comments: this.comments
    };
    await super.saveData(dataToSave);
    this.refreshEditorDecorations();
  }
  /**
   * Refresh editor decorations for all open markdown views
   */
  refreshEditorDecorations() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian.MarkdownView) {
        const editor = leaf.view.editor;
        if (editor && editor.cm) {
          const cm = editor.cm;
          if (cm.dispatch) {
            cm.dispatch({ effects: [forceUpdateEffect.of(null)] });
          }
        }
      }
    });
  }
  /**
   * Create ViewPlugin for highlighting comments in editor
   */
  createHighlightPlugin() {
    const plugin = this;
    return import_view.ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = this.buildDecorations(view);
        this.view.dom.addEventListener("click", this.handleClick.bind(this));
      }
      destroy() {
        this.view.dom.removeEventListener("click", this.handleClick.bind(this));
      }
      handleClick(event) {
        const target = event.target;
        const highlight = target.closest(".sidenote-highlight");
        if (highlight) {
          const timestampStr = highlight.getAttribute("data-comment-timestamp");
          if (timestampStr) {
            const timestamp = parseInt(timestampStr, 10);
            plugin.activateViewAndHighlightComment(timestamp);
          }
        }
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.transactions.some((tr) => tr.effects.some((e) => e.is(forceUpdateEffect)))) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      buildDecorations(view) {
        const builder = new import_state.RangeSetBuilder();
        if (!plugin.settings.showHighlights) {
          return builder.finish();
        }
        let filePath = null;
        plugin.app.workspace.iterateAllLeaves((leaf) => {
          if (leaf.view instanceof import_obsidian.MarkdownView && leaf.view.file) {
            const editor = leaf.view.editor;
            if (editor && editor.cm === view) {
              filePath = leaf.view.file.path;
            }
          }
        });
        if (!filePath) return builder.finish();
        const comments = plugin.commentManager.getCommentsForFile(filePath);
        const doc = view.state.doc;
        const decorationsArray = [];
        comments.forEach((comment) => {
          try {
            if (comment.isOrphaned) {
              const line = doc.line(comment.startLine + 1);
              const from = line.from + comment.startChar;
              const to = Math.min(from + 1, line.to);
              if (from >= 0 && to <= doc.length && from < to) {
                decorationsArray.push({
                  from,
                  to,
                  decoration: import_view.Decoration.mark({
                    class: "sidenote-highlight orphaned",
                    attributes: {
                      "data-comment-timestamp": comment.timestamp.toString()
                    }
                  })
                });
              }
            } else {
              const line = doc.line(comment.startLine + 1);
              const from = line.from + comment.startChar;
              const to = line.from + comment.endChar;
              if (from >= 0 && to <= doc.length && from < to) {
                decorationsArray.push({
                  from,
                  to,
                  decoration: import_view.Decoration.mark({
                    class: "sidenote-highlight",
                    attributes: {
                      "data-comment-timestamp": comment.timestamp.toString()
                    }
                  })
                });
              }
            }
          } catch (e) {
            console.warn("Failed to create decoration for comment:", e);
          }
        });
        decorationsArray.sort((a, b) => a.from - b.from);
        decorationsArray.forEach(({ from, to, decoration }) => {
          builder.add(from, to, decoration);
        });
        return builder.finish();
      }
    }, {
      decorations: (v) => v.decorations
    });
  }
};


/* nosourcemap */